公粮. 

[题目在这]()

说给定一个从 1 到 n 排序的整数列表. 

首先,从左到右, 从第一个数字开始, 每隔一个数字进行删除, 直到列表的末尾. 

第二步, 在剩下的数字中, 从右到左, 从倒数第一个数字开始, 每隔一个数字进行删除, 直到列表开头. 

我们不断重复这两步, 从左到右和从右到左交替进行, 直到只剩下一个数字. 

返回长度为 n 的列表中, 最后剩下的数字. 

举个例子: 
> 输入: n = 9 时,
> 1 2 3 4 5 6 7 8 9
> 2 4 6 8
> 2 6
> 6
>
> 输出: 6

这个东西的话一看就知道是找规律的问题 (正常的大模拟少说也要 O(n), 显然不能接受). 

找规律就讲究一个说... 错了, 讲究一个从现象中发现结论. 

经过精(cha)心(zhao)发(zi)现(liao), 有以下几个结论 (这些结论都是显然的, 谈不上证明什么的): 

1. 除了 1 外, 所有的数字结果均为偶数;
2. 除了 1 外, 所有奇数 n 的操作结果和 n-1 的相同;
3. 把这个过程当作对某个列表的过程, 最终剩下的数字在列表中的位置不变;
4. 从 3. 可以知道, 对 n~1 的列表进行如上过程的结果和对 1~n 的列表进行如上过程的结果相加为 n+1 (在列表中相对位置相同, 对称性可知);
5. 另一方面, 对 1~n 列表进行如上过程的结果和对 n/2~1 的列表进行如上过程的结果为两倍关系 (这个相对不显然, 参见下方博客的解释);

因此可以得到最终的递归方法, 见代码:

```
class Solution {
public:
    int lastRemaining(int n) {
        // From https://leetcode.com/problems/elimination-game/discuss/87116/Java-Recursion-and-Proof
        // Detailed explaination also seen in https://blog.csdn.net/afei__/article/details/83689502
        return n == 1 ? 1 :2 * (n / 2 + 1 - lastRemaining(n / 2));
    }
};
```
