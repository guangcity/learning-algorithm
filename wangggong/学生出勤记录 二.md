# 学生出勤记录 二

公粮. 新年快乐. 

分上下两部分, 这是下半部分. 

话说一开始有这么一个问题 (学生出勤记录 一): 

给定一个字符串代表学生的一个出勤记录, 包含 `A (absent)`, `L (late)`, `P (present)` 三种记录方式. 

如果一个学生的出勤记录中不超过一个 `A` 或者不超过两个连续的 `L` 就会被奖赏. 问给定一个记录来判断是否会被奖赏. 

简单题, 但这个是它的变种. 

说设定同上, 给定一个正整数 `n`, 返回所有被奖赏的出勤记录的数量. 答案需要模 `1e9+7`. 

比如说: 

> 输入: n = 2
>
> 输出: 8
>
> 解释: "PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL" 等 8 种记录会受到奖励. 事实上, 只有 "AA" 不会被奖励. 

这里我先说一下这个 `1e9+7`. 说起来你可能不信, 这个数是一个质数, 还是最接近一亿的质数. 感兴趣的可以在 [Wolfram Alpha](wolframalpha.com) 搜索 "prime nearest to 10000000". 至于 Wolfram Alpha 嘛, 是一个很有意思的搜索引擎, 可以 "计算" 一些奇怪的东西, 此处按下不表. 你问我这个知识有什么用? 可以装逼啊! 

扯远了. 事实上, 选用这个数字取模有以下几个原因: 

1. 如刚才所说, 这是 10 位最小质数. 质数怎么了呢? 质数好就好在取模后结果相对分散 (这也是哈希表构造过程中会考虑的一些问题). 举个例子, 如果你成功地 "抿" 出结果一定是一个偶数, 但你在此以上放弃了思考 (假设你像我一样废), 那这个时候让你输出模 4 的结果就只可能是 0 或者 2, 而让你输出模 3 的结果就没什么变化. 这样可以减少 "蒙对" 的概率 (从中可以见到出题人的险恶用心); 
2. 说回这个数字, 只有原因 1 的话那大家随便选一个质数好了, 但这个数字本身有一个好处: 一方面它**足够大**, 大到结果范围可以看成是 `[0, 1e9+6]` 范围内近似均匀分布的结果; 另一方面它还**不会太大**, 两个 `1e9+7` 相加不爆 `int`, 两个 `1e9+7` 相乘不爆 `long long`. 
3. 这里其实还没完. 实际上, 满足这两个条件的数字也不少, 大概 `3.55M` 个. 为啥挑中了它呢? 个人理解因为好记呗! 我第一次看见这个数字的时候不是用科学计数法写的, 是这么写的: `1000000007`. 是不是印象深刻? (光数零就得数半天

回到题目. 这个题目一说到会出现大数取模, `n` 的范围还在 `[0,100000]` 之间, 考虑暴力就是徒劳的. 贪心? 不像吧. 那就只能是 DP 了. 

DP 的话, 需要考虑初始状态, 状态和状态转移: 
1. 初始状态就是长度为 `0` 或 `1` 的状态, 这里选的是长度为 `1` 的;
2. 状态是 `n` 长度下出勤记录的数量; 
3. 状态转移则相当于在问: **给定一个 `n-1` 长度的受奖赏记录, 你怎么变成 `n` 长度的受奖赏记录呢?**

考虑通过在 `n-1` 长度的受奖赏记录后面添加记录进行状态转移的方式, 那就分类讨论呗! 

根据奖赏条件, 容易将记录分为以下几种: 
- 没缺过勤的/缺过一次勤的; 
- 没迟到过的/迟到过一次的/迟到过两次的. (这里只需要考虑最后一次/最后两次迟到, 想想为什么. )

排列组合有六种可能. 对这六种可能进行状态转移的讨论, 以 "长度为 `n-1` 没缺过勤最后两次迟到" 的记录为例: 

这个记录八成长这样: `'XXX...XLL', X != 'A'`, 那这之后可以添 `'P'`, 变成 "长度为 `n` 没缺过勤最后一次没迟到" 的记录; 可以添 `'A'` 变成 "长度为 `n` 缺过一次勤最后一次没迟到" 的记录. 完成状态转移. 

其余同理, 不赘述. 上代码: 

```
class RECORD {
public:
    long long notA_0L;
    long long notA_1L;
    long long notA_2L;
    long long A_0L;
    long long A_1L;
    long long A_2L;

    RECORD(int u, int v, int w, int x, int y, int z) : \
        notA_0L (u), notA_1L (v), notA_2L (w), \
        A_0L (x), A_1L (y), A_2L (z) {}
}

const int BIG_INT = 1000000007;

int checkRecord(int n) {
    RECORD rec(1, 1, 0, 1, 0, 0);
    for (int i = 1; i < n; i++) {
        long long notA_0L = rec.notA_0L;
        long long notA_1L = rec.notA_1L;
        long long notA_2L = rec.notA_2L;
        long long A_0L = rec.A_0L;
        long long A_1L = rec.A_1L;
        long long A_2L = rec.A_2L;

        rec.notA_0L = (notA_0L + notA_1L + notA_2L) % BIG_INT;
        rec.notA_1L = (notA_0L) % BIG_INT;
        rec.notA_2L = (notA_1L) % BIG_INT;
        rec.A_0L    = (notA_0L + notA_1L + notA_2L + A_0L + A_1L + A_2L) % BIG_INT;
        rec.A_1L    = A_0L;
        rec.A_2L    = A_1L;
    }

    return (rec.notA_0L + rec.notA_1L + rec.notA_2L + rec.A_0L + rec.A_1L + rec.A_2L) % BIG_INT;
}
```
