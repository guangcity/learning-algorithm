# 全局倒置与局部倒置

学到了学到了. 

题目如下: 

数组 A 是 [0, 1, ..., N - 1] 的一种排列, N 是数组 A 的长度. 全局倒置指的是 i,j 满足 0 <= i < j < N 并且 A[i] > A[j] , 局部倒置指的是 i 满足 0 <= i < N 并且 A[i] > A[i+1] . 

当数组 A 中全局倒置的数量等于局部倒置的数量时, 返回 true . 

举个例子: 

> **输入**: A = [1,0,2]
> **输出**: true
> **解释**: 有 1 个全局倒置和 1 个局部倒置. 

反之, 

> **输入**: A = [1,2,0]
> **输出**: false
> **解释**: 有 2 个全局倒置和 1 个局部倒置. 

讲道理一开始的思路还挺对... 就是说题目本身其实问的是这么一件事: 

**如何判断数组里面存在*非局部倒置的全局倒置*?**

也就是说: 

**如何判断数组里面存在*位置隔一个 (或以上) 的倒置*?**

比如这个 [1,2,0], 其中的 1 和 0 就属于位置隔了一个的倒置. 

怎么判断呢? 有这么两个办法: 

办法 1. 判断数组前面 *i* 个元素的**最大值**比第 *i+2* 个元素大. 

就有这样的代码: 

```
bool isIdealPermutation(vector<int>& A) {
    int maxVal = INT_MIN;
    for (int i = 0; i+2 < A.size(); i++) {
        maxVal = max(A[i], maxVal);
        if (maxVal > A[i+2]) { return false; }
    }
    return true;
}
```

办法 2. 如果数组里面存在一个元素, 元素值和索引值之间绝对值差距 > 1, 就说明存在非局部倒置的全局倒置. 

比如 [1,2,0], 我们说 0 哈... 由于它现在在第 2 个位置, 就导致 1 被挤到与 0 相隔一个的位置 (同理换了 2 也如此). 

因此这题有一个看上去及其简单的写法, 长这样: 

```
bool isIdealPermutation(vector<int>& A) {
    for (int i = 0; i < A.size(); i++) {
        if (abs(A[i] - i) > 1) { return false; }
    }
    return true;
}
```