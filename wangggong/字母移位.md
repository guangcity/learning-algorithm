# 字母移位

公粮. [题目看这里](https://leetcode-cn.com/problems/shifting-letters/description/)

题目是这样的: 有一个由小写字母组成的字符串 `S`, 和一个整数数组 `shifts`. 

我们将字母表中的下一个字母称为原字母的 "移位" (由于字母表是环绕的,  `'z'` 将会变成 `'a'`). 

例如, `shift('a') = 'b'`, `shift('t') = 'u'`, 以及 `shift('z') = 'a'`. 对于每个 `shifts[i] = x`,  我们会将 `S` 中的前 `i+1` 个字母移位 `x` 次. 
返回将所有这些移位都应用到 `S` 后最终得到的字符串. 

题目本身不难, 但我想聊一些密码学的东西. 不扯淡. 

这个题目和密码学啥关系呢? 这个题目简化一下就是一个加密方法: **凯撒加密** ([度娘](https://baike.baidu.com/item/%E6%81%BA%E6%92%92%E5%8A%A0%E5%AF%86/8934458?fr=aladdin)). 

凯撒加密就是把明文中每个字母都移位相同的次数. 就比如把 `VENI VEDI VECI` 加个密 shift 4 次, 就成了 `ZIRM ZIHM ZIGM`, 看上去就很混淆. (嘛相比于原文, 原文也是凯撒大帝的名言)

一切非常顺利 -- 但架不住密码学就是个**魔高一尺道高一丈**的领域... 

这个方法优点在于非常简单粗暴, 而且双方约定移位次数的前提下能以极低成本生成相对可用的密文. 但反过来, 简单的加密方式带来的就是简单的解密方式 (相对简单的解密方式, 当然不能一眼看出, 但相比于分解大素数简单多了) -- 频率分析. 比如, 已知是凯撒加密的前提下, 上面的密文可以看到字母 `x` 和字母 `x+13` 相对多一些 (3 个), 这个就大大减小了暴力破解需要尝试的数目. 

-- 而这个, 在今天这道问题这里可以得到一定的解决. (终于绕过来了)

话不多说, 上代码. 

```
string shiftingLetters(string S, vector<int>& shifts) {
    S[S.size()-1] = 'a' + (S[S.size()-1] - 'a' + shifts[S.size()-1]) % 26;
    for (int i = shifts.size()-2; i >= 0; i--) {
        shifts[i] += shifts[i+1];
        shifts[i] %= 26;
        S[i] = 'a' + (S[i] - 'a' + shifts[i]) % 26;
    }
    return S;
}
```
