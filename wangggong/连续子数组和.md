# 连续子数组和

公粮. [题目看这里](https://leetcode-cn.com/problems/continuous-subarray-sum/description/)

题目是这样的: 给定一个**非负整数组**和一个目标**整数** `k`, 判断是否含有长度不小于 2 的连续子数组, 其和能被 `k` 整除. 

比如: 

> 输入: [23,2,4,6,7], k=6
>
> 输出: True
>
> 解释: [2,4] 长度为 2, 和为 6. 

题目很简单, 只需要对数组进行一个预处理 `cumsum`. 为什么需要经过一个预处理呢? 

暴力的想法无非是: 我们遍历子数组的起点 `i` 和终点 `j`, 如果子数组的和能被 `k` 整除则皆大欢喜. 时间复杂度为 `O(n^3)`, 不可接受. 

但仔细一想, 会有大量的重复计算发生. 比如, `sum(A[0:5]) == sum(A[0:3]) + sum(A[3:5])` 恒成立. 也就是说, 这个过程可以简化为 `sum(A[i:j]) == sum(A[0:j]) - sum(A[0:i])`, 而后面的两项就是 `cumsum` 的结果. 这时, 时间复杂度就变成了 `O(n^2)`. 效率得到了提升. 上代码: 

```
bool checkSubarraySum(vector<int>& A, int k) {
    k = abs(k);     // 坑爹的用例, 还有负数... 
    unordered_map<int, int> Mpos;
    vector<int> Vcum;
    Vcum.push_back(0);
    for (int i = 0; i < A.size(); i++) {
        Vcum.push_back((*Vcum.rbegin()) + nums[i]);
    }
    for (int i = 0; i < Vcum.size(); i++) {
        int ind = k == 0 ? Vcum[i] : Vcum[i] % k;   // 坑爹的用例, 还有 0... 
        if (Mpos.count(ind)) {
            if (i - Mpos[ind] >= 2) {
                return true;
            }
        } else {
            Mpos[ind] = i;
        }
    }
    return false;
}
```
