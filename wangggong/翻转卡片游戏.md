# 翻转卡片游戏

公粮. [题目看这里](https://leetcode-cn.com/problems/card-flipping-game/description/)

题目是这样的: 在桌上有若干张卡片 (不妨就设为 `N` 吧), 每张卡正面背面都有一个数 (可能相等可能不等). 可以翻转任意张卡片, 再选一张. 若该卡片的背面数字 `X` 和任意一张卡片正面的数字都不一样, 就是我们想要的数字. 求 `X` 的最小值. 

比如: 

> 输入: fronts=[1,2,4,4,7], backs=[1,3,1,4,3]
>
> 输出: 2
>
> 解释: 翻转第二张卡片, 就变成了 `[1,3,4,4,7]` 和 `[1,2,4,1,3]`. 这时第二张卡片即满足条件, 且为最小值. 

一开始看上去感觉应该是一个贪心吧... 把最大的数字翻到正面, 然后反面找最小的不就得了嘛. 

然后振振有词: 你看, 对每一对 `[fronts[i],backs[i]]` 而言, 既然是找最小值, 就先确定这个值是这个对中的最小值就好嘛. 

然后就被打脸了:

> 输入: fronts=[1,1], backs=[1,2]
>
> 输出: 2

所以不对. 仔细想想, 确实应该是一个贪心, 但是不是这么贪的: 

对样例输入: 首先, 你先选最小值 `1`, 结果发现不行. 为啥不行呢? 重复了. 和谁重复了呢? 是和 `backs[2]` 重复吗? 不是, 因为这个可以转过去变成 `3`. 所以**它是和自己重复了**. 

就是说, 若你的 你的正面和反面一样 (`fronts[i] == backs[i]`), 那你是全局最小值也没用. 

那反过来呢? 

继续说: 然后, 你选择 `2` (除了 `1` 之外最小了嘛), 然后满足条件. 事实上, 即使有重复的, 正面再出现一个 `2` 也无所谓, 翻过去就好. 但如果出现正面反面都是 `2`, 就翻不过去了. 

因此: 

你需要先维护一个集合, 记录正反面相同的数字. 然后在正反面所有数字中找到没在集合中的最小数字, 就一定满足. 因为一定有策略把正面和它重复的数字都翻到背面去. 时间复杂度 `O(n)`, 空间复杂度 `O(n)`. 

于是, 上代码: 

```
int flipgame(vector<int>& fs, vector<int>& bs) {
    unordered_set<int> S;
    for (int i = 0; i < fs.size(); i++) if (fs[i] == bs[i]) {
        S.insert(fs[i]);
    }
    int res = INT_MAX;
    for (auto num : fs) if (!S.count(num) && num < res) {
        res = num;
    }
    for (auto num : bs) if (!S.count(num) && num < res) {
        res = num;
    }
    return res == INT_MAX ? 0 : res;
}
```
