# 学生出勤记录

公粮. 

分上下两部分, 先说上半部分. 

给定一个字符串代表学生的一个出勤记录, 包含 `A (absent)`, `L (late)`, `P (present)` 三种记录方式. 

如果一个学生的出勤记录中不超过一个 `A` 或者不超过两个连续的 `L` 就会被奖赏. 

比如: 

> 输入: "PPALLP"
> 输出: true
> 解释: 没啥解释的, 出勤就一次 `A`, 两个连续的 `L`(在做死的边缘大鹏展翅.jpg) 

再比如: 

> 输入: "PPALLL"
> 输出: false
> 解释: 和上面的差不多, 出勤就一次 `A`, 但是有了三个连续的 `L`(在做死的边缘大鹏展翅--没搂住.jpg) 

题目很简单, 也很暴力. 

**遍历**字符串, 每次遍历时判断有几个 `A`, 如果有超过两个 `A` 即返回 `False`; 然后判断当前是第几个连续的 `L`, 如果前面已经有一个 `L` 这个还是 `L` 那就是两个连续的, 如果前面已经有两个 `L` 这个还是 `L` 那就是三个连续的... 
如果不是 `L`, 那就重置连续的 `L` 的数目为 0.

Easy, huh? 所以上来就是写: 

```
bool checkRecord(string s) {
    int cntA = 0;
    int lastL = 0;
    for (char ch : S) {
        if (ch == 'A') { if (++cntA > 1) { return false;} }
        else if (ch == 'L') {
            if (++lastL > 2) { return false; }
            continue;
        } else { lastL = 0; }
    }
    return true;
}
```

满怀信心来一发, 告诉我错了. 诶? 这么简单的逻辑怎么可能错? 

一看: 

> 输入: "LALL"
> 输出: false
> 预期: true

仔细一想, 没问题啊, 人家的 3 个 `L` 不连续, 所以应该返回 `true`. 诶这里应该重置状态了啊? 这是为什么呢? 猜猜看. 

附上正确代码: 

```
bool checkRecord(string s) {
    int cntA = 0;
    int lastL = 0;
    for (char ch : S) {
        if (ch == 'L') {
            if (++lastL > 2) { return false; }
            continue;
        } else {
            if (ch == 'A') { if (++cntA > 1) { return false;} }
            lastL = 0;
        }
    }
    return true;
}
```

一般来讲, 这种题目思路比较清晰, 就一定尽量一次性做对, 不要犯低级错误. **一次又一次傻逼一样的提交然后 WA, 陷入 "急急忙忙提交->WA->装作 Debug->急急忙忙又提交->WA->..." 的循环, 即使最后对了, 那也不是本事. 反而会给自己一种 "下次慎重一些就能对了~" 的错觉.**

不过总之这个题目还算简单啦~ 不愧是简单题, 这么简单的设定就出不来难题的~ 我这么想着. 

真的是这样吗? 

[未完待续]

注: 电脑崩了, 所以本来打算一次性写完的结题报告水一水就写两次了, 原谅我吧. 关于电脑是如何 "**文体两开花**" 的, 那就是另外一个故事了. 
